<!-- Copyright 2014 The Chromium Authors. All rights reserved.
     Use of this source code is governed by a BSD-style license that can be
     found in the LICENSE file. -->

<import src="/gen/mojo/public/sky/bindings.sky" as="bindings" />
<import src="/gen/mojo/public/sky/codec.sky" as="codec" />
<import src="/gen/mojo/public/sky/connection.sky" as="connection" />
<import src="/gen/mojo/public/sky/core.sky" as="core" />
<import src="/gen/mojo/public/sky/validator.sky" as="validator" />
<script>
  var EventType = {};
  EventType.UNKNOWN = 0;
  EventType.POINTER_DOWN = EventType.UNKNOWN + 1;
  EventType.POINTER_UP = EventType.POINTER_DOWN + 1;
  EventType.POINTER_MOVE = EventType.POINTER_UP + 1;
  EventType.POINTER_CANCEL = EventType.POINTER_MOVE + 1;
  var PointerKind = {};
  PointerKind.TOUCH = 0;

  function PointerData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PointerData.prototype.initDefaults_ = function() {
    this.pointer = 0;
    this.kind = 0;
    this.x = 0;
    this.y = 0;
    this.buttons = 0;
    this.pressure = 0;
    this.pressure_min = 0;
    this.pressure_max = 0;
    this.distance = 0;
    this.distance_min = 0;
    this.distance_max = 0;
    this.radius_major = 0;
    this.radius_minor = 0;
    this.radius_min = 0;
    this.radius_max = 0;
    this.orientation = 0;
    this.tilt = 0;
  };
  PointerData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PointerData.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, PointerData.encodedSize, 17);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PointerData.encodedSize = codec.kStructHeaderSize + 72;

  PointerData.decode = function(decoder) {
    var packed;
    var val = new PointerData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pointer = decoder.decodeStruct(codec.Int32);
    val.kind = decoder.decodeStruct(codec.Int32);
    val.x = decoder.decodeStruct(codec.Float);
    val.y = decoder.decodeStruct(codec.Float);
    val.buttons = decoder.decodeStruct(codec.Int32);
    val.pressure = decoder.decodeStruct(codec.Float);
    val.pressure_min = decoder.decodeStruct(codec.Float);
    val.pressure_max = decoder.decodeStruct(codec.Float);
    val.distance = decoder.decodeStruct(codec.Float);
    val.distance_min = decoder.decodeStruct(codec.Float);
    val.distance_max = decoder.decodeStruct(codec.Float);
    val.radius_major = decoder.decodeStruct(codec.Float);
    val.radius_minor = decoder.decodeStruct(codec.Float);
    val.radius_min = decoder.decodeStruct(codec.Float);
    val.radius_max = decoder.decodeStruct(codec.Float);
    val.orientation = decoder.decodeStruct(codec.Float);
    val.tilt = decoder.decodeStruct(codec.Float);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  PointerData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PointerData.encodedSize);
    encoder.writeUint32(17);
    encoder.encodeStruct(codec.Int32, val.pointer);
    encoder.encodeStruct(codec.Int32, val.kind);
    encoder.encodeStruct(codec.Float, val.x);
    encoder.encodeStruct(codec.Float, val.y);
    encoder.encodeStruct(codec.Int32, val.buttons);
    encoder.encodeStruct(codec.Float, val.pressure);
    encoder.encodeStruct(codec.Float, val.pressure_min);
    encoder.encodeStruct(codec.Float, val.pressure_max);
    encoder.encodeStruct(codec.Float, val.distance);
    encoder.encodeStruct(codec.Float, val.distance_min);
    encoder.encodeStruct(codec.Float, val.distance_max);
    encoder.encodeStruct(codec.Float, val.radius_major);
    encoder.encodeStruct(codec.Float, val.radius_minor);
    encoder.encodeStruct(codec.Float, val.radius_min);
    encoder.encodeStruct(codec.Float, val.radius_max);
    encoder.encodeStruct(codec.Float, val.orientation);
    encoder.encodeStruct(codec.Float, val.tilt);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };

  function InputEvent(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  InputEvent.prototype.initDefaults_ = function() {
    this.type = 0;
    this.time_stamp = 0;
    this.pointer_data = null;
  };
  InputEvent.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  InputEvent.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, InputEvent.encodedSize, 3);
    if (err !== validator.validationError.NONE)
        return err;
    // validate InputEvent.pointer_data
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, PointerData, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  InputEvent.encodedSize = codec.kStructHeaderSize + 24;

  InputEvent.decode = function(decoder) {
    var packed;
    var val = new InputEvent();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.type = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.time_stamp = decoder.decodeStruct(codec.Int64);
    val.pointer_data = decoder.decodeStructPointer(PointerData);
    return val;
  };

  InputEvent.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(InputEvent.encodedSize);
    encoder.writeUint32(3);
    encoder.encodeStruct(codec.Int32, val.type);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int64, val.time_stamp);
    encoder.encodeStructPointer(PointerData, val.pointer_data);
  };


  var exports = {};
  exports.EventType = EventType;
  exports.PointerKind = PointerKind;
  exports.PointerData = PointerData;
  exports.InputEvent = InputEvent;

  module.exports = exports;
</script>
