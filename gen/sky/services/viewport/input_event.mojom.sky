<!-- Copyright 2014 The Chromium Authors. All rights reserved.
     Use of this source code is governed by a BSD-style license that can be
     found in the LICENSE file. -->

<import src="/gen/mojo/public/sky/bindings.sky" as="bindings" />
<import src="/gen/mojo/public/sky/codec.sky" as="codec" />
<import src="/gen/mojo/public/sky/connection.sky" as="connection" />
<import src="/gen/mojo/public/sky/core.sky" as="core" />
<import src="/gen/mojo/public/sky/validator.sky" as="validator" />
<script>
  var EventType = {};
  EventType.UNKNOWN = 0;
  EventType.POINTER_DOWN = EventType.UNKNOWN + 1;
  EventType.POINTER_UP = EventType.POINTER_DOWN + 1;
  EventType.POINTER_MOVE = EventType.POINTER_UP + 1;
  EventType.POINTER_CANCEL = EventType.POINTER_MOVE + 1;
  EventType.GESTURE_SCROLL_BEGIN = EventType.POINTER_CANCEL + 1;
  EventType.GESTURE_SCROLL_UPDATE = EventType.GESTURE_SCROLL_BEGIN + 1;
  EventType.GESTURE_SCROLL_END = EventType.GESTURE_SCROLL_UPDATE + 1;
  EventType.GESTURE_FLING_START = EventType.GESTURE_SCROLL_END + 1;
  EventType.GESTURE_FLING_CANCEL = EventType.GESTURE_FLING_START + 1;
  var PointerKind = {};
  PointerKind.TOUCH = 0;

  function PointerData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PointerData.prototype.initDefaults_ = function() {
    this.pointer = 0;
    this.kind = 0;
    this.x = 0;
    this.y = 0;
    this.buttons = 0;
    this.pressure = 0;
    this.pressure_min = 0;
    this.pressure_max = 0;
    this.distance = 0;
    this.distance_min = 0;
    this.distance_max = 0;
    this.radius_major = 0;
    this.radius_minor = 0;
    this.radius_min = 0;
    this.radius_max = 0;
    this.orientation = 0;
    this.tilt = 0;
  };
  PointerData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PointerData.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, PointerData.encodedSize, 17);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PointerData.encodedSize = codec.kStructHeaderSize + 72;

  PointerData.decode = function(decoder) {
    var packed;
    var val = new PointerData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pointer = decoder.decodeStruct(codec.Int32);
    val.kind = decoder.decodeStruct(codec.Int32);
    val.x = decoder.decodeStruct(codec.Float);
    val.y = decoder.decodeStruct(codec.Float);
    val.buttons = decoder.decodeStruct(codec.Int32);
    val.pressure = decoder.decodeStruct(codec.Float);
    val.pressure_min = decoder.decodeStruct(codec.Float);
    val.pressure_max = decoder.decodeStruct(codec.Float);
    val.distance = decoder.decodeStruct(codec.Float);
    val.distance_min = decoder.decodeStruct(codec.Float);
    val.distance_max = decoder.decodeStruct(codec.Float);
    val.radius_major = decoder.decodeStruct(codec.Float);
    val.radius_minor = decoder.decodeStruct(codec.Float);
    val.radius_min = decoder.decodeStruct(codec.Float);
    val.radius_max = decoder.decodeStruct(codec.Float);
    val.orientation = decoder.decodeStruct(codec.Float);
    val.tilt = decoder.decodeStruct(codec.Float);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  PointerData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PointerData.encodedSize);
    encoder.writeUint32(17);
    encoder.encodeStruct(codec.Int32, val.pointer);
    encoder.encodeStruct(codec.Int32, val.kind);
    encoder.encodeStruct(codec.Float, val.x);
    encoder.encodeStruct(codec.Float, val.y);
    encoder.encodeStruct(codec.Int32, val.buttons);
    encoder.encodeStruct(codec.Float, val.pressure);
    encoder.encodeStruct(codec.Float, val.pressure_min);
    encoder.encodeStruct(codec.Float, val.pressure_max);
    encoder.encodeStruct(codec.Float, val.distance);
    encoder.encodeStruct(codec.Float, val.distance_min);
    encoder.encodeStruct(codec.Float, val.distance_max);
    encoder.encodeStruct(codec.Float, val.radius_major);
    encoder.encodeStruct(codec.Float, val.radius_minor);
    encoder.encodeStruct(codec.Float, val.radius_min);
    encoder.encodeStruct(codec.Float, val.radius_max);
    encoder.encodeStruct(codec.Float, val.orientation);
    encoder.encodeStruct(codec.Float, val.tilt);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };

  function GestureData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GestureData.prototype.initDefaults_ = function() {
    this.x = 0;
    this.y = 0;
    this.dx = 0;
    this.dy = 0;
    this.velocityX = 0;
    this.velocityY = 0;
  };
  GestureData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GestureData.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, GestureData.encodedSize, 6);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GestureData.encodedSize = codec.kStructHeaderSize + 24;

  GestureData.decode = function(decoder) {
    var packed;
    var val = new GestureData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.x = decoder.decodeStruct(codec.Float);
    val.y = decoder.decodeStruct(codec.Float);
    val.dx = decoder.decodeStruct(codec.Float);
    val.dy = decoder.decodeStruct(codec.Float);
    val.velocityX = decoder.decodeStruct(codec.Float);
    val.velocityY = decoder.decodeStruct(codec.Float);
    return val;
  };

  GestureData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GestureData.encodedSize);
    encoder.writeUint32(6);
    encoder.encodeStruct(codec.Float, val.x);
    encoder.encodeStruct(codec.Float, val.y);
    encoder.encodeStruct(codec.Float, val.dx);
    encoder.encodeStruct(codec.Float, val.dy);
    encoder.encodeStruct(codec.Float, val.velocityX);
    encoder.encodeStruct(codec.Float, val.velocityY);
  };

  function InputEvent(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  InputEvent.prototype.initDefaults_ = function() {
    this.type = 0;
    this.time_stamp = 0;
    this.pointer_data = null;
    this.gesture_data = null;
  };
  InputEvent.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  InputEvent.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, InputEvent.encodedSize, 4);
    if (err !== validator.validationError.NONE)
        return err;
    // validate InputEvent.pointer_data
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, PointerData, true);
    if (err !== validator.validationError.NONE)
        return err;
    // validate InputEvent.gesture_data
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, GestureData, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  InputEvent.encodedSize = codec.kStructHeaderSize + 32;

  InputEvent.decode = function(decoder) {
    var packed;
    var val = new InputEvent();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.type = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.time_stamp = decoder.decodeStruct(codec.Int64);
    val.pointer_data = decoder.decodeStructPointer(PointerData);
    val.gesture_data = decoder.decodeStructPointer(GestureData);
    return val;
  };

  InputEvent.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(InputEvent.encodedSize);
    encoder.writeUint32(4);
    encoder.encodeStruct(codec.Int32, val.type);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int64, val.time_stamp);
    encoder.encodeStructPointer(PointerData, val.pointer_data);
    encoder.encodeStructPointer(GestureData, val.gesture_data);
  };


  var exports = {};
  exports.EventType = EventType;
  exports.PointerKind = PointerKind;
  exports.PointerData = PointerData;
  exports.GestureData = GestureData;
  exports.InputEvent = InputEvent;

  module.exports = exports;
</script>
