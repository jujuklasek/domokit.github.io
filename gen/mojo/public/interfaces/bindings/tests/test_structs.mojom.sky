<!-- Copyright 2014 The Chromium Authors. All rights reserved.
     Use of this source code is governed by a BSD-style license that can be
     found in the LICENSE file. -->

<import src="/gen/mojo/public/sky/bindings.sky" as="bindings" />
<import src="/gen/mojo/public/sky/codec.sky" as="codec" />
<import src="/gen/mojo/public/sky/connection.sky" as="connection" />
<import src="/gen/mojo/public/sky/core.sky" as="core" />
<import src="/gen/mojo/public/sky/validator.sky" as="validator" />
<import src="/gen/mojo/public/interfaces/bindings/tests/rect.mojom.sky" as="rect$" />
<script>

  function NamedRegion(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  NamedRegion.prototype.initDefaults_ = function() {
    this.name = null;
    this.rects = null;
  };
  NamedRegion.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  NamedRegion.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, NamedRegion.encodedSize, 2);
    if (err !== validator.validationError.NONE)
        return err;
    // validate NamedRegion.name
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, true)
    if (err !== validator.validationError.NONE)
        return err;
    // validate NamedRegion.rects
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, new codec.PointerTo(rect$.Rect), true, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  NamedRegion.encodedSize = codec.kStructHeaderSize + 16;

  NamedRegion.decode = function(decoder) {
    var packed;
    var val = new NamedRegion();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.name = decoder.decodeStruct(codec.NullableString);
    val.rects = decoder.decodeArrayPointer(new codec.PointerTo(rect$.Rect));
    return val;
  };

  NamedRegion.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(NamedRegion.encodedSize);
    encoder.writeUint32(2);
    encoder.encodeStruct(codec.NullableString, val.name);
    encoder.encodeArrayPointer(new codec.PointerTo(rect$.Rect), val.rects);
  };

  function RectPair(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  RectPair.prototype.initDefaults_ = function() {
    this.first = null;
    this.second = null;
  };
  RectPair.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  RectPair.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, RectPair.encodedSize, 2);
    if (err !== validator.validationError.NONE)
        return err;
    // validate RectPair.first
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, rect$.Rect, true);
    if (err !== validator.validationError.NONE)
        return err;
    // validate RectPair.second
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, rect$.Rect, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  RectPair.encodedSize = codec.kStructHeaderSize + 16;

  RectPair.decode = function(decoder) {
    var packed;
    var val = new RectPair();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.first = decoder.decodeStructPointer(rect$.Rect);
    val.second = decoder.decodeStructPointer(rect$.Rect);
    return val;
  };

  RectPair.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(RectPair.encodedSize);
    encoder.writeUint32(2);
    encoder.encodeStructPointer(rect$.Rect, val.first);
    encoder.encodeStructPointer(rect$.Rect, val.second);
  };

  function EmptyStruct(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  EmptyStruct.prototype.initDefaults_ = function() {
  };
  EmptyStruct.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  EmptyStruct.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, EmptyStruct.encodedSize, 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  EmptyStruct.encodedSize = codec.kStructHeaderSize + 0;

  EmptyStruct.decode = function(decoder) {
    var packed;
    var val = new EmptyStruct();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  EmptyStruct.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(EmptyStruct.encodedSize);
    encoder.writeUint32(0);
  };

  function NoDefaultFieldValues(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  NoDefaultFieldValues.prototype.initDefaults_ = function() {
    this.f0 = false;
    this.f1 = 0;
    this.f2 = 0;
    this.f3 = 0;
    this.f4 = 0;
    this.f5 = 0;
    this.f6 = 0;
    this.f7 = 0;
    this.f8 = 0;
    this.f9 = 0;
    this.f13 = null;
    this.f10 = 0;
    this.f11 = null;
    this.f12 = null;
    this.f14 = null;
    this.f15 = null;
    this.f16 = null;
    this.f17 = null;
    this.f18 = null;
    this.f19 = null;
    this.f20 = null;
    this.f21 = null;
    this.f22 = null;
    this.f23 = null;
    this.f24 = null;
    this.f25 = null;
    this.f26 = null;
    this.f27 = null;
    this.f28 = null;
  };
  NoDefaultFieldValues.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  NoDefaultFieldValues.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, NoDefaultFieldValues.encodedSize, 29);
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f13
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 36, false)
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f11
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 48, false)
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f12
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 56, true)
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f14
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 64, false)
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f15
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 68, false)
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f16
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 72, true)
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f17
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 76, true)
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f18
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 80, true)
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f19
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 84, false)
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f20
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 88, true)
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f21
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 92, false)
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f22
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 96, true)
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f23
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 104, 8, codec.String, false, [0, 0], 0);
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f24
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 112, 8, codec.NullableString, false, [0, 0], 0);
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f25
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 120, 8, codec.String, true, [0, 0], 0);
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f26
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 128, 8, codec.NullableString, true, [0, 0], 0);
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f27
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 136, EmptyStruct, false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate NoDefaultFieldValues.f28
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 144, EmptyStruct, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  NoDefaultFieldValues.encodedSize = codec.kStructHeaderSize + 152;

  NoDefaultFieldValues.decode = function(decoder) {
    var packed;
    var val = new NoDefaultFieldValues();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f0 = decoder.decodeStruct(codec.Uint8);
    val.f1 = decoder.decodeStruct(codec.Int8);
    val.f2 = decoder.decodeStruct(codec.Uint8);
    decoder.skip(1);
    val.f3 = decoder.decodeStruct(codec.Int16);
    val.f4 = decoder.decodeStruct(codec.Uint16);
    val.f5 = decoder.decodeStruct(codec.Int32);
    val.f6 = decoder.decodeStruct(codec.Uint32);
    val.f7 = decoder.decodeStruct(codec.Int64);
    val.f8 = decoder.decodeStruct(codec.Uint64);
    val.f9 = decoder.decodeStruct(codec.Float);
    val.f13 = decoder.decodeStruct(codec.Handle);
    val.f10 = decoder.decodeStruct(codec.Double);
    val.f11 = decoder.decodeStruct(codec.String);
    val.f12 = decoder.decodeStruct(codec.NullableString);
    val.f14 = decoder.decodeStruct(codec.Handle);
    val.f15 = decoder.decodeStruct(codec.Handle);
    val.f16 = decoder.decodeStruct(codec.NullableHandle);
    val.f17 = decoder.decodeStruct(codec.NullableHandle);
    val.f18 = decoder.decodeStruct(codec.NullableHandle);
    val.f19 = decoder.decodeStruct(codec.Handle);
    val.f20 = decoder.decodeStruct(codec.NullableHandle);
    val.f21 = decoder.decodeStruct(codec.Handle);
    val.f22 = decoder.decodeStruct(codec.NullableHandle);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.f23 = decoder.decodeArrayPointer(codec.String);
    val.f24 = decoder.decodeArrayPointer(codec.NullableString);
    val.f25 = decoder.decodeArrayPointer(codec.String);
    val.f26 = decoder.decodeArrayPointer(codec.NullableString);
    val.f27 = decoder.decodeStructPointer(EmptyStruct);
    val.f28 = decoder.decodeStructPointer(EmptyStruct);
    return val;
  };

  NoDefaultFieldValues.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(NoDefaultFieldValues.encodedSize);
    encoder.writeUint32(29);
    encoder.encodeStruct(codec.Uint8, val.f0);
    encoder.encodeStruct(codec.Int8, val.f1);
    encoder.encodeStruct(codec.Uint8, val.f2);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int16, val.f3);
    encoder.encodeStruct(codec.Uint16, val.f4);
    encoder.encodeStruct(codec.Int32, val.f5);
    encoder.encodeStruct(codec.Uint32, val.f6);
    encoder.encodeStruct(codec.Int64, val.f7);
    encoder.encodeStruct(codec.Uint64, val.f8);
    encoder.encodeStruct(codec.Float, val.f9);
    encoder.encodeStruct(codec.Handle, val.f13);
    encoder.encodeStruct(codec.Double, val.f10);
    encoder.encodeStruct(codec.String, val.f11);
    encoder.encodeStruct(codec.NullableString, val.f12);
    encoder.encodeStruct(codec.Handle, val.f14);
    encoder.encodeStruct(codec.Handle, val.f15);
    encoder.encodeStruct(codec.NullableHandle, val.f16);
    encoder.encodeStruct(codec.NullableHandle, val.f17);
    encoder.encodeStruct(codec.NullableHandle, val.f18);
    encoder.encodeStruct(codec.Handle, val.f19);
    encoder.encodeStruct(codec.NullableHandle, val.f20);
    encoder.encodeStruct(codec.Handle, val.f21);
    encoder.encodeStruct(codec.NullableHandle, val.f22);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeArrayPointer(codec.String, val.f23);
    encoder.encodeArrayPointer(codec.NullableString, val.f24);
    encoder.encodeArrayPointer(codec.String, val.f25);
    encoder.encodeArrayPointer(codec.NullableString, val.f26);
    encoder.encodeStructPointer(EmptyStruct, val.f27);
    encoder.encodeStructPointer(EmptyStruct, val.f28);
  };

  function DefaultFieldValues(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DefaultFieldValues.kFoo = "foo";
  DefaultFieldValues.prototype.initDefaults_ = function() {
    this.f0 = true;
    this.f1 = 100;
    this.f2 = 100;
    this.f3 = 100;
    this.f4 = 100;
    this.f5 = 100;
    this.f6 = 100;
    this.f7 = 100;
    this.f8 = 100;
    this.f9 = 100;
    this.f10 = 100.0;
    this.f11 = 100;
    this.f12 = 100.0;
    this.f13 = DefaultFieldValues.kFoo;
    this.f14 = DefaultFieldValues.kFoo;
    this.f15 = new rect$.Rect();
    this.f16 = new rect$.Rect();
  };
  DefaultFieldValues.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DefaultFieldValues.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, DefaultFieldValues.encodedSize, 17);
    if (err !== validator.validationError.NONE)
        return err;
    // validate DefaultFieldValues.f13
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 56, false)
    if (err !== validator.validationError.NONE)
        return err;
    // validate DefaultFieldValues.f14
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 64, true)
    if (err !== validator.validationError.NONE)
        return err;
    // validate DefaultFieldValues.f15
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 72, rect$.Rect, false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate DefaultFieldValues.f16
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 80, rect$.Rect, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  DefaultFieldValues.encodedSize = codec.kStructHeaderSize + 88;

  DefaultFieldValues.decode = function(decoder) {
    var packed;
    var val = new DefaultFieldValues();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f0 = decoder.decodeStruct(codec.Uint8);
    val.f1 = decoder.decodeStruct(codec.Int8);
    val.f2 = decoder.decodeStruct(codec.Uint8);
    decoder.skip(1);
    val.f3 = decoder.decodeStruct(codec.Int16);
    val.f4 = decoder.decodeStruct(codec.Uint16);
    val.f5 = decoder.decodeStruct(codec.Int32);
    val.f6 = decoder.decodeStruct(codec.Uint32);
    val.f7 = decoder.decodeStruct(codec.Int64);
    val.f8 = decoder.decodeStruct(codec.Uint64);
    val.f9 = decoder.decodeStruct(codec.Float);
    val.f10 = decoder.decodeStruct(codec.Float);
    val.f11 = decoder.decodeStruct(codec.Double);
    val.f12 = decoder.decodeStruct(codec.Double);
    val.f13 = decoder.decodeStruct(codec.String);
    val.f14 = decoder.decodeStruct(codec.NullableString);
    val.f15 = decoder.decodeStructPointer(rect$.Rect);
    val.f16 = decoder.decodeStructPointer(rect$.Rect);
    return val;
  };

  DefaultFieldValues.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DefaultFieldValues.encodedSize);
    encoder.writeUint32(17);
    encoder.encodeStruct(codec.Uint8, val.f0);
    encoder.encodeStruct(codec.Int8, val.f1);
    encoder.encodeStruct(codec.Uint8, val.f2);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int16, val.f3);
    encoder.encodeStruct(codec.Uint16, val.f4);
    encoder.encodeStruct(codec.Int32, val.f5);
    encoder.encodeStruct(codec.Uint32, val.f6);
    encoder.encodeStruct(codec.Int64, val.f7);
    encoder.encodeStruct(codec.Uint64, val.f8);
    encoder.encodeStruct(codec.Float, val.f9);
    encoder.encodeStruct(codec.Float, val.f10);
    encoder.encodeStruct(codec.Double, val.f11);
    encoder.encodeStruct(codec.Double, val.f12);
    encoder.encodeStruct(codec.String, val.f13);
    encoder.encodeStruct(codec.NullableString, val.f14);
    encoder.encodeStructPointer(rect$.Rect, val.f15);
    encoder.encodeStructPointer(rect$.Rect, val.f16);
  };

  function ScopedConstants(values) {
    this.initDefaults_();
    this.initFields_(values);
  }

  ScopedConstants.EType = {};
  ScopedConstants.EType.E0 = 0;
  ScopedConstants.EType.E1 = ScopedConstants.EType.E0 + 1;
  ScopedConstants.EType.E2 = 10;
  ScopedConstants.EType.E3 = ScopedConstants.EType.E2;
  ScopedConstants.EType.E4 = ScopedConstants.EType.E3 + 1;

  ScopedConstants.TEN = 10;
  ScopedConstants.ALSO_TEN = ScopedConstants.TEN;
  ScopedConstants.TEN_TOO = ScopedConstants.EType.E2;
  ScopedConstants.prototype.initDefaults_ = function() {
    this.f0 = ScopedConstants.EType.E0;
    this.f1 = ScopedConstants.EType.E1;
    this.f2 = ScopedConstants.EType.E2;
    this.f3 = ScopedConstants.EType.E3;
    this.f4 = ScopedConstants.EType.E4;
    this.f5 = ScopedConstants.TEN;
    this.f6 = ScopedConstants.ALSO_TEN;
  };
  ScopedConstants.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ScopedConstants.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, ScopedConstants.encodedSize, 7);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ScopedConstants.encodedSize = codec.kStructHeaderSize + 32;

  ScopedConstants.decode = function(decoder) {
    var packed;
    var val = new ScopedConstants();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f0 = decoder.decodeStruct(codec.Int32);
    val.f1 = decoder.decodeStruct(codec.Int32);
    val.f2 = decoder.decodeStruct(codec.Int32);
    val.f3 = decoder.decodeStruct(codec.Int32);
    val.f4 = decoder.decodeStruct(codec.Int32);
    val.f5 = decoder.decodeStruct(codec.Int32);
    val.f6 = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  ScopedConstants.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ScopedConstants.encodedSize);
    encoder.writeUint32(7);
    encoder.encodeStruct(codec.Int32, val.f0);
    encoder.encodeStruct(codec.Int32, val.f1);
    encoder.encodeStruct(codec.Int32, val.f2);
    encoder.encodeStruct(codec.Int32, val.f3);
    encoder.encodeStruct(codec.Int32, val.f4);
    encoder.encodeStruct(codec.Int32, val.f5);
    encoder.encodeStruct(codec.Int32, val.f6);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };

  function MapKeyTypes(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  MapKeyTypes.prototype.initDefaults_ = function() {
    this.f0 = null;
    this.f1 = null;
    this.f2 = null;
    this.f3 = null;
    this.f4 = null;
    this.f5 = null;
    this.f6 = null;
    this.f7 = null;
    this.f8 = null;
    this.f9 = null;
    this.f10 = null;
    this.f11 = null;
  };
  MapKeyTypes.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  MapKeyTypes.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, MapKeyTypes.encodedSize, 12);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapKeyTypes.f0
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 0, false, codec.PackedBool, codec.PackedBool, false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapKeyTypes.f1
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 8, false, codec.Int8, codec.Int8, false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapKeyTypes.f2
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 16, false, codec.Uint8, codec.Uint8, false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapKeyTypes.f3
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 24, false, codec.Int16, codec.Int16, false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapKeyTypes.f4
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 32, false, codec.Uint16, codec.Uint16, false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapKeyTypes.f5
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 40, false, codec.Int32, codec.Int32, false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapKeyTypes.f6
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 48, false, codec.Uint32, codec.Uint32, false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapKeyTypes.f7
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 56, false, codec.Int64, codec.Int64, false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapKeyTypes.f8
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 64, false, codec.Uint64, codec.Uint64, false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapKeyTypes.f9
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 72, false, codec.Float, codec.Float, false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapKeyTypes.f10
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 80, false, codec.Double, codec.Double, false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapKeyTypes.f11
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 88, false, codec.String, codec.String, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  MapKeyTypes.encodedSize = codec.kStructHeaderSize + 96;

  MapKeyTypes.decode = function(decoder) {
    var packed;
    var val = new MapKeyTypes();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f0 = decoder.decodeMapPointer(codec.PackedBool, codec.PackedBool);
    val.f1 = decoder.decodeMapPointer(codec.Int8, codec.Int8);
    val.f2 = decoder.decodeMapPointer(codec.Uint8, codec.Uint8);
    val.f3 = decoder.decodeMapPointer(codec.Int16, codec.Int16);
    val.f4 = decoder.decodeMapPointer(codec.Uint16, codec.Uint16);
    val.f5 = decoder.decodeMapPointer(codec.Int32, codec.Int32);
    val.f6 = decoder.decodeMapPointer(codec.Uint32, codec.Uint32);
    val.f7 = decoder.decodeMapPointer(codec.Int64, codec.Int64);
    val.f8 = decoder.decodeMapPointer(codec.Uint64, codec.Uint64);
    val.f9 = decoder.decodeMapPointer(codec.Float, codec.Float);
    val.f10 = decoder.decodeMapPointer(codec.Double, codec.Double);
    val.f11 = decoder.decodeMapPointer(codec.String, codec.String);
    return val;
  };

  MapKeyTypes.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(MapKeyTypes.encodedSize);
    encoder.writeUint32(12);
    encoder.encodeMapPointer(codec.PackedBool, codec.PackedBool, val.f0);
    encoder.encodeMapPointer(codec.Int8, codec.Int8, val.f1);
    encoder.encodeMapPointer(codec.Uint8, codec.Uint8, val.f2);
    encoder.encodeMapPointer(codec.Int16, codec.Int16, val.f3);
    encoder.encodeMapPointer(codec.Uint16, codec.Uint16, val.f4);
    encoder.encodeMapPointer(codec.Int32, codec.Int32, val.f5);
    encoder.encodeMapPointer(codec.Uint32, codec.Uint32, val.f6);
    encoder.encodeMapPointer(codec.Int64, codec.Int64, val.f7);
    encoder.encodeMapPointer(codec.Uint64, codec.Uint64, val.f8);
    encoder.encodeMapPointer(codec.Float, codec.Float, val.f9);
    encoder.encodeMapPointer(codec.Double, codec.Double, val.f10);
    encoder.encodeMapPointer(codec.String, codec.String, val.f11);
  };

  function MapValueTypes(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  MapValueTypes.prototype.initDefaults_ = function() {
    this.f0 = null;
    this.f1 = null;
    this.f2 = null;
    this.f3 = null;
    this.f4 = null;
    this.f5 = null;
    this.f6 = null;
    this.f7 = null;
    this.f8 = null;
  };
  MapValueTypes.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  MapValueTypes.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, MapValueTypes.encodedSize, 9);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapValueTypes.f0
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 0, false, codec.String, new codec.ArrayOf(codec.String), false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapValueTypes.f1
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 8, false, codec.String, new codec.NullableArrayOf(codec.String), true);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapValueTypes.f2
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 16, false, codec.String, new codec.ArrayOf(codec.NullableString), false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapValueTypes.f3
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 24, false, codec.String, new codec.ArrayOf(codec.String, 2), false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapValueTypes.f4
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 32, false, codec.String, new codec.ArrayOf(new codec.NullableArrayOf(codec.String, 2)), false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapValueTypes.f5
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 40, false, codec.String, new codec.ArrayOf(new codec.ArrayOf(codec.String, 2), 1), false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapValueTypes.f6
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 48, false, codec.String, new codec.NullablePointerTo(rect$.Rect), true);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapValueTypes.f7
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 56, false, codec.String, new codec.MapOf(codec.String, codec.String), false);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MapValueTypes.f8
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 64, false, codec.String, new codec.ArrayOf(new codec.MapOf(codec.String, codec.String)), false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  MapValueTypes.encodedSize = codec.kStructHeaderSize + 72;

  MapValueTypes.decode = function(decoder) {
    var packed;
    var val = new MapValueTypes();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f0 = decoder.decodeMapPointer(codec.String, new codec.ArrayOf(codec.String));
    val.f1 = decoder.decodeMapPointer(codec.String, new codec.NullableArrayOf(codec.String));
    val.f2 = decoder.decodeMapPointer(codec.String, new codec.ArrayOf(codec.NullableString));
    val.f3 = decoder.decodeMapPointer(codec.String, new codec.ArrayOf(codec.String, 2));
    val.f4 = decoder.decodeMapPointer(codec.String, new codec.ArrayOf(new codec.NullableArrayOf(codec.String, 2)));
    val.f5 = decoder.decodeMapPointer(codec.String, new codec.ArrayOf(new codec.ArrayOf(codec.String, 2), 1));
    val.f6 = decoder.decodeMapPointer(codec.String, new codec.NullablePointerTo(rect$.Rect));
    val.f7 = decoder.decodeMapPointer(codec.String, new codec.MapOf(codec.String, codec.String));
    val.f8 = decoder.decodeMapPointer(codec.String, new codec.ArrayOf(new codec.MapOf(codec.String, codec.String)));
    return val;
  };

  MapValueTypes.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(MapValueTypes.encodedSize);
    encoder.writeUint32(9);
    encoder.encodeMapPointer(codec.String, new codec.ArrayOf(codec.String), val.f0);
    encoder.encodeMapPointer(codec.String, new codec.NullableArrayOf(codec.String), val.f1);
    encoder.encodeMapPointer(codec.String, new codec.ArrayOf(codec.NullableString), val.f2);
    encoder.encodeMapPointer(codec.String, new codec.ArrayOf(codec.String, 2), val.f3);
    encoder.encodeMapPointer(codec.String, new codec.ArrayOf(new codec.NullableArrayOf(codec.String, 2)), val.f4);
    encoder.encodeMapPointer(codec.String, new codec.ArrayOf(new codec.ArrayOf(codec.String, 2), 1), val.f5);
    encoder.encodeMapPointer(codec.String, new codec.NullablePointerTo(rect$.Rect), val.f6);
    encoder.encodeMapPointer(codec.String, new codec.MapOf(codec.String, codec.String), val.f7);
    encoder.encodeMapPointer(codec.String, new codec.ArrayOf(new codec.MapOf(codec.String, codec.String)), val.f8);
  };

  function ArrayValueTypes(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ArrayValueTypes.prototype.initDefaults_ = function() {
    this.f0 = null;
    this.f1 = null;
    this.f2 = null;
    this.f3 = null;
    this.f4 = null;
    this.f5 = null;
  };
  ArrayValueTypes.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ArrayValueTypes.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, ArrayValueTypes.encodedSize, 6);
    if (err !== validator.validationError.NONE)
        return err;
    // validate ArrayValueTypes.f0
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 1, codec.Int8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;
    // validate ArrayValueTypes.f1
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 2, codec.Int16, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;
    // validate ArrayValueTypes.f2
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 4, codec.Int32, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;
    // validate ArrayValueTypes.f3
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 8, codec.Int64, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;
    // validate ArrayValueTypes.f4
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 32, 4, codec.Float, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;
    // validate ArrayValueTypes.f5
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 40, 8, codec.Double, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ArrayValueTypes.encodedSize = codec.kStructHeaderSize + 48;

  ArrayValueTypes.decode = function(decoder) {
    var packed;
    var val = new ArrayValueTypes();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f0 = decoder.decodeArrayPointer(codec.Int8);
    val.f1 = decoder.decodeArrayPointer(codec.Int16);
    val.f2 = decoder.decodeArrayPointer(codec.Int32);
    val.f3 = decoder.decodeArrayPointer(codec.Int64);
    val.f4 = decoder.decodeArrayPointer(codec.Float);
    val.f5 = decoder.decodeArrayPointer(codec.Double);
    return val;
  };

  ArrayValueTypes.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ArrayValueTypes.encodedSize);
    encoder.writeUint32(6);
    encoder.encodeArrayPointer(codec.Int8, val.f0);
    encoder.encodeArrayPointer(codec.Int16, val.f1);
    encoder.encodeArrayPointer(codec.Int32, val.f2);
    encoder.encodeArrayPointer(codec.Int64, val.f3);
    encoder.encodeArrayPointer(codec.Float, val.f4);
    encoder.encodeArrayPointer(codec.Double, val.f5);
  };

  function FloatNumberValues(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FloatNumberValues.V0 = Infinity;
  FloatNumberValues.V1 = -Infinity;
  FloatNumberValues.V2 = NaN;
  FloatNumberValues.V3 = Infinity;
  FloatNumberValues.V4 = -Infinity;
  FloatNumberValues.V5 = NaN;
  FloatNumberValues.V6 = 0;
  FloatNumberValues.V7 = 1234567890.123;
  FloatNumberValues.V8 = 1.2E+20;
  FloatNumberValues.V9 = -1.2E+20;
  FloatNumberValues.prototype.initDefaults_ = function() {
    this.f0 = FloatNumberValues.V0;
    this.f1 = FloatNumberValues.V1;
    this.f2 = FloatNumberValues.V2;
    this.f3 = FloatNumberValues.V3;
    this.f4 = FloatNumberValues.V4;
    this.f5 = FloatNumberValues.V5;
    this.f6 = FloatNumberValues.V6;
    this.f7 = FloatNumberValues.V7;
    this.f8 = FloatNumberValues.V8;
    this.f9 = FloatNumberValues.V9;
  };
  FloatNumberValues.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FloatNumberValues.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, FloatNumberValues.encodedSize, 10);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  FloatNumberValues.encodedSize = codec.kStructHeaderSize + 64;

  FloatNumberValues.decode = function(decoder) {
    var packed;
    var val = new FloatNumberValues();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f0 = decoder.decodeStruct(codec.Double);
    val.f1 = decoder.decodeStruct(codec.Double);
    val.f2 = decoder.decodeStruct(codec.Double);
    val.f3 = decoder.decodeStruct(codec.Float);
    val.f4 = decoder.decodeStruct(codec.Float);
    val.f5 = decoder.decodeStruct(codec.Float);
    val.f6 = decoder.decodeStruct(codec.Float);
    val.f7 = decoder.decodeStruct(codec.Double);
    val.f8 = decoder.decodeStruct(codec.Double);
    val.f9 = decoder.decodeStruct(codec.Double);
    return val;
  };

  FloatNumberValues.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FloatNumberValues.encodedSize);
    encoder.writeUint32(10);
    encoder.encodeStruct(codec.Double, val.f0);
    encoder.encodeStruct(codec.Double, val.f1);
    encoder.encodeStruct(codec.Double, val.f2);
    encoder.encodeStruct(codec.Float, val.f3);
    encoder.encodeStruct(codec.Float, val.f4);
    encoder.encodeStruct(codec.Float, val.f5);
    encoder.encodeStruct(codec.Float, val.f6);
    encoder.encodeStruct(codec.Double, val.f7);
    encoder.encodeStruct(codec.Double, val.f8);
    encoder.encodeStruct(codec.Double, val.f9);
  };

  function IntegerNumberValues(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  IntegerNumberValues.V0 = -128;
  IntegerNumberValues.V1 = -1;
  IntegerNumberValues.V2 = 0;
  IntegerNumberValues.V3 = 42;
  IntegerNumberValues.V4 = 127;
  IntegerNumberValues.V5 = -32768;
  IntegerNumberValues.V6 = -1;
  IntegerNumberValues.V7 = 0;
  IntegerNumberValues.V8 = 12345;
  IntegerNumberValues.V9 = 32767;
  IntegerNumberValues.V10 = -2147483648;
  IntegerNumberValues.V11 = -1;
  IntegerNumberValues.V12 = 0;
  IntegerNumberValues.V13 = 1234567890;
  IntegerNumberValues.V14 = 2147483647;
  IntegerNumberValues.V15 = -9007199254740991;
  IntegerNumberValues.V16 = -1;
  IntegerNumberValues.V17 = 0;
  IntegerNumberValues.V18 = 1234567890123456;
  IntegerNumberValues.V19 = 9007199254740991;
  IntegerNumberValues.prototype.initDefaults_ = function() {
    this.f0 = IntegerNumberValues.V0;
    this.f1 = IntegerNumberValues.V1;
    this.f2 = IntegerNumberValues.V2;
    this.f3 = IntegerNumberValues.V3;
    this.f4 = IntegerNumberValues.V4;
    this.f5 = IntegerNumberValues.V5;
    this.f6 = IntegerNumberValues.V6;
    this.f7 = IntegerNumberValues.V7;
    this.f8 = IntegerNumberValues.V8;
    this.f9 = IntegerNumberValues.V9;
    this.f10 = IntegerNumberValues.V10;
    this.f11 = IntegerNumberValues.V11;
    this.f12 = IntegerNumberValues.V12;
    this.f13 = IntegerNumberValues.V13;
    this.f14 = IntegerNumberValues.V14;
    this.f15 = IntegerNumberValues.V15;
    this.f16 = IntegerNumberValues.V16;
    this.f17 = IntegerNumberValues.V17;
    this.f18 = IntegerNumberValues.V18;
    this.f19 = IntegerNumberValues.V19;
  };
  IntegerNumberValues.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  IntegerNumberValues.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, IntegerNumberValues.encodedSize, 20);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  IntegerNumberValues.encodedSize = codec.kStructHeaderSize + 80;

  IntegerNumberValues.decode = function(decoder) {
    var packed;
    var val = new IntegerNumberValues();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f0 = decoder.decodeStruct(codec.Int8);
    val.f1 = decoder.decodeStruct(codec.Int8);
    val.f2 = decoder.decodeStruct(codec.Int8);
    val.f3 = decoder.decodeStruct(codec.Int8);
    val.f4 = decoder.decodeStruct(codec.Int8);
    decoder.skip(1);
    val.f5 = decoder.decodeStruct(codec.Int16);
    val.f6 = decoder.decodeStruct(codec.Int16);
    val.f7 = decoder.decodeStruct(codec.Int16);
    val.f8 = decoder.decodeStruct(codec.Int16);
    val.f9 = decoder.decodeStruct(codec.Int16);
    val.f10 = decoder.decodeStruct(codec.Int32);
    val.f11 = decoder.decodeStruct(codec.Int32);
    val.f12 = decoder.decodeStruct(codec.Int32);
    val.f13 = decoder.decodeStruct(codec.Int32);
    val.f14 = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.f15 = decoder.decodeStruct(codec.Int64);
    val.f16 = decoder.decodeStruct(codec.Int64);
    val.f17 = decoder.decodeStruct(codec.Int64);
    val.f18 = decoder.decodeStruct(codec.Int64);
    val.f19 = decoder.decodeStruct(codec.Int64);
    return val;
  };

  IntegerNumberValues.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(IntegerNumberValues.encodedSize);
    encoder.writeUint32(20);
    encoder.encodeStruct(codec.Int8, val.f0);
    encoder.encodeStruct(codec.Int8, val.f1);
    encoder.encodeStruct(codec.Int8, val.f2);
    encoder.encodeStruct(codec.Int8, val.f3);
    encoder.encodeStruct(codec.Int8, val.f4);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int16, val.f5);
    encoder.encodeStruct(codec.Int16, val.f6);
    encoder.encodeStruct(codec.Int16, val.f7);
    encoder.encodeStruct(codec.Int16, val.f8);
    encoder.encodeStruct(codec.Int16, val.f9);
    encoder.encodeStruct(codec.Int32, val.f10);
    encoder.encodeStruct(codec.Int32, val.f11);
    encoder.encodeStruct(codec.Int32, val.f12);
    encoder.encodeStruct(codec.Int32, val.f13);
    encoder.encodeStruct(codec.Int32, val.f14);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int64, val.f15);
    encoder.encodeStruct(codec.Int64, val.f16);
    encoder.encodeStruct(codec.Int64, val.f17);
    encoder.encodeStruct(codec.Int64, val.f18);
    encoder.encodeStruct(codec.Int64, val.f19);
  };

  function UnsignedNumberValues(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  UnsignedNumberValues.V0 = 0;
  UnsignedNumberValues.V1 = 42;
  UnsignedNumberValues.V2 = 0xFF;
  UnsignedNumberValues.V3 = 0;
  UnsignedNumberValues.V4 = 12345;
  UnsignedNumberValues.V5 = 0xFFFF;
  UnsignedNumberValues.V6 = 0;
  UnsignedNumberValues.V7 = 1234567890;
  UnsignedNumberValues.V8 = 0xFFFFFFFF;
  UnsignedNumberValues.V9 = 0;
  UnsignedNumberValues.V10 = 1234567890123456;
  UnsignedNumberValues.V11 = 9007199254740991;
  UnsignedNumberValues.prototype.initDefaults_ = function() {
    this.f0 = UnsignedNumberValues.V0;
    this.f1 = UnsignedNumberValues.V1;
    this.f2 = UnsignedNumberValues.V2;
    this.f3 = UnsignedNumberValues.V3;
    this.f4 = UnsignedNumberValues.V4;
    this.f5 = UnsignedNumberValues.V5;
    this.f6 = UnsignedNumberValues.V6;
    this.f7 = UnsignedNumberValues.V7;
    this.f8 = UnsignedNumberValues.V8;
    this.f9 = UnsignedNumberValues.V9;
    this.f10 = UnsignedNumberValues.V10;
    this.f11 = UnsignedNumberValues.V11;
  };
  UnsignedNumberValues.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  UnsignedNumberValues.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, UnsignedNumberValues.encodedSize, 12);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  UnsignedNumberValues.encodedSize = codec.kStructHeaderSize + 48;

  UnsignedNumberValues.decode = function(decoder) {
    var packed;
    var val = new UnsignedNumberValues();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f0 = decoder.decodeStruct(codec.Uint8);
    val.f1 = decoder.decodeStruct(codec.Uint8);
    val.f2 = decoder.decodeStruct(codec.Uint8);
    decoder.skip(1);
    val.f3 = decoder.decodeStruct(codec.Uint16);
    val.f4 = decoder.decodeStruct(codec.Uint16);
    val.f5 = decoder.decodeStruct(codec.Uint16);
    decoder.skip(1);
    decoder.skip(1);
    val.f6 = decoder.decodeStruct(codec.Uint32);
    val.f7 = decoder.decodeStruct(codec.Uint32);
    val.f8 = decoder.decodeStruct(codec.Uint32);
    val.f9 = decoder.decodeStruct(codec.Uint64);
    val.f10 = decoder.decodeStruct(codec.Uint64);
    val.f11 = decoder.decodeStruct(codec.Uint64);
    return val;
  };

  UnsignedNumberValues.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(UnsignedNumberValues.encodedSize);
    encoder.writeUint32(12);
    encoder.encodeStruct(codec.Uint8, val.f0);
    encoder.encodeStruct(codec.Uint8, val.f1);
    encoder.encodeStruct(codec.Uint8, val.f2);
    encoder.skip(1);
    encoder.encodeStruct(codec.Uint16, val.f3);
    encoder.encodeStruct(codec.Uint16, val.f4);
    encoder.encodeStruct(codec.Uint16, val.f5);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Uint32, val.f6);
    encoder.encodeStruct(codec.Uint32, val.f7);
    encoder.encodeStruct(codec.Uint32, val.f8);
    encoder.encodeStruct(codec.Uint64, val.f9);
    encoder.encodeStruct(codec.Uint64, val.f10);
    encoder.encodeStruct(codec.Uint64, val.f11);
  };

  function BitArrayValues(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  BitArrayValues.prototype.initDefaults_ = function() {
    this.f0 = null;
    this.f1 = null;
    this.f2 = null;
    this.f3 = null;
    this.f4 = null;
    this.f5 = null;
    this.f6 = null;
  };
  BitArrayValues.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  BitArrayValues.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, BitArrayValues.encodedSize, 7);
    if (err !== validator.validationError.NONE)
        return err;
    // validate BitArrayValues.f0
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 1, codec.PackedBool, false, [1], 0);
    if (err !== validator.validationError.NONE)
        return err;
    // validate BitArrayValues.f1
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 1, codec.PackedBool, false, [7], 0);
    if (err !== validator.validationError.NONE)
        return err;
    // validate BitArrayValues.f2
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 1, codec.PackedBool, false, [9], 0);
    if (err !== validator.validationError.NONE)
        return err;
    // validate BitArrayValues.f3
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 1, codec.PackedBool, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;
    // validate BitArrayValues.f4
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 32, 8, new codec.ArrayOf(codec.PackedBool), false, [0, 0], 0);
    if (err !== validator.validationError.NONE)
        return err;
    // validate BitArrayValues.f5
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 40, 8, new codec.NullableArrayOf(codec.PackedBool), false, [0, 0], 0);
    if (err !== validator.validationError.NONE)
        return err;
    // validate BitArrayValues.f6
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 48, 8, new codec.NullableArrayOf(codec.PackedBool, 2), false, [0, 2], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  BitArrayValues.encodedSize = codec.kStructHeaderSize + 56;

  BitArrayValues.decode = function(decoder) {
    var packed;
    var val = new BitArrayValues();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f0 = decoder.decodeArrayPointer(codec.PackedBool);
    val.f1 = decoder.decodeArrayPointer(codec.PackedBool);
    val.f2 = decoder.decodeArrayPointer(codec.PackedBool);
    val.f3 = decoder.decodeArrayPointer(codec.PackedBool);
    val.f4 = decoder.decodeArrayPointer(new codec.ArrayOf(codec.PackedBool));
    val.f5 = decoder.decodeArrayPointer(new codec.NullableArrayOf(codec.PackedBool));
    val.f6 = decoder.decodeArrayPointer(new codec.NullableArrayOf(codec.PackedBool, 2));
    return val;
  };

  BitArrayValues.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(BitArrayValues.encodedSize);
    encoder.writeUint32(7);
    encoder.encodeArrayPointer(codec.PackedBool, val.f0);
    encoder.encodeArrayPointer(codec.PackedBool, val.f1);
    encoder.encodeArrayPointer(codec.PackedBool, val.f2);
    encoder.encodeArrayPointer(codec.PackedBool, val.f3);
    encoder.encodeArrayPointer(new codec.ArrayOf(codec.PackedBool), val.f4);
    encoder.encodeArrayPointer(new codec.NullableArrayOf(codec.PackedBool), val.f5);
    encoder.encodeArrayPointer(new codec.NullableArrayOf(codec.PackedBool, 2), val.f6);
  };

  function MultiVersionStruct(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  MultiVersionStruct.prototype.initDefaults_ = function() {
    this.f_int32 = 0;
    this.f_message_pipe = null;
    this.f_rect = null;
    this.f_string = null;
    this.f_array = null;
    this.f_bool = false;
    this.f_int16 = 0;
  };
  MultiVersionStruct.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  MultiVersionStruct.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, MultiVersionStruct.encodedSize, 9);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MultiVersionStruct.f_message_pipe
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 4, true)
    if (err !== validator.validationError.NONE)
        return err;
    // validate MultiVersionStruct.f_rect
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, rect$.Rect, true);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MultiVersionStruct.f_string
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 16, true)
    if (err !== validator.validationError.NONE)
        return err;
    // validate MultiVersionStruct.f_array
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 1, codec.Int8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  MultiVersionStruct.encodedSize = codec.kStructHeaderSize + 40;

  MultiVersionStruct.decode = function(decoder) {
    var packed;
    var val = new MultiVersionStruct();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f_int32 = decoder.decodeStruct(codec.Int32);
    val.f_message_pipe = decoder.decodeStruct(codec.NullableHandle);
    val.f_rect = decoder.decodeStructPointer(rect$.Rect);
    val.f_string = decoder.decodeStruct(codec.NullableString);
    val.f_array = decoder.decodeArrayPointer(codec.Int8);
    val.f_bool = decoder.decodeStruct(codec.Uint8);
    decoder.skip(1);
    val.f_int16 = decoder.decodeStruct(codec.Int16);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  MultiVersionStruct.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(MultiVersionStruct.encodedSize);
    encoder.writeUint32(9);
    encoder.encodeStruct(codec.Int32, val.f_int32);
    encoder.encodeStruct(codec.NullableHandle, val.f_message_pipe);
    encoder.encodeStructPointer(rect$.Rect, val.f_rect);
    encoder.encodeStruct(codec.NullableString, val.f_string);
    encoder.encodeArrayPointer(codec.Int8, val.f_array);
    encoder.encodeStruct(codec.Uint8, val.f_bool);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int16, val.f_int16);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };

  function MultiVersionStructV0(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  MultiVersionStructV0.prototype.initDefaults_ = function() {
    this.f_int32 = 0;
  };
  MultiVersionStructV0.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  MultiVersionStructV0.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, MultiVersionStructV0.encodedSize, 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  MultiVersionStructV0.encodedSize = codec.kStructHeaderSize + 8;

  MultiVersionStructV0.decode = function(decoder) {
    var packed;
    var val = new MultiVersionStructV0();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f_int32 = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  MultiVersionStructV0.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(MultiVersionStructV0.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.f_int32);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };

  function MultiVersionStructV1(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  MultiVersionStructV1.prototype.initDefaults_ = function() {
    this.f_int32 = 0;
    this.f_rect = null;
  };
  MultiVersionStructV1.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  MultiVersionStructV1.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, MultiVersionStructV1.encodedSize, 1);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MultiVersionStructV1.f_rect
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, rect$.Rect, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  MultiVersionStructV1.encodedSize = codec.kStructHeaderSize + 16;

  MultiVersionStructV1.decode = function(decoder) {
    var packed;
    var val = new MultiVersionStructV1();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f_int32 = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.f_rect = decoder.decodeStructPointer(rect$.Rect);
    return val;
  };

  MultiVersionStructV1.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(MultiVersionStructV1.encodedSize);
    encoder.writeUint32(1);
    encoder.encodeStruct(codec.Int32, val.f_int32);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(rect$.Rect, val.f_rect);
  };

  function MultiVersionStructV3(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  MultiVersionStructV3.prototype.initDefaults_ = function() {
    this.f_int32 = 0;
    this.f_rect = null;
    this.f_string = null;
  };
  MultiVersionStructV3.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  MultiVersionStructV3.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, MultiVersionStructV3.encodedSize, 3);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MultiVersionStructV3.f_rect
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, rect$.Rect, true);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MultiVersionStructV3.f_string
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 16, true)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  MultiVersionStructV3.encodedSize = codec.kStructHeaderSize + 24;

  MultiVersionStructV3.decode = function(decoder) {
    var packed;
    var val = new MultiVersionStructV3();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f_int32 = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.f_rect = decoder.decodeStructPointer(rect$.Rect);
    val.f_string = decoder.decodeStruct(codec.NullableString);
    return val;
  };

  MultiVersionStructV3.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(MultiVersionStructV3.encodedSize);
    encoder.writeUint32(3);
    encoder.encodeStruct(codec.Int32, val.f_int32);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(rect$.Rect, val.f_rect);
    encoder.encodeStruct(codec.NullableString, val.f_string);
  };

  function MultiVersionStructV5(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  MultiVersionStructV5.prototype.initDefaults_ = function() {
    this.f_int32 = 0;
    this.f_rect = null;
    this.f_string = null;
    this.f_array = null;
  };
  MultiVersionStructV5.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  MultiVersionStructV5.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, MultiVersionStructV5.encodedSize, 5);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MultiVersionStructV5.f_rect
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, rect$.Rect, true);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MultiVersionStructV5.f_string
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 16, true)
    if (err !== validator.validationError.NONE)
        return err;
    // validate MultiVersionStructV5.f_array
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 1, codec.Int8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  MultiVersionStructV5.encodedSize = codec.kStructHeaderSize + 32;

  MultiVersionStructV5.decode = function(decoder) {
    var packed;
    var val = new MultiVersionStructV5();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f_int32 = decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.f_rect = decoder.decodeStructPointer(rect$.Rect);
    val.f_string = decoder.decodeStruct(codec.NullableString);
    val.f_array = decoder.decodeArrayPointer(codec.Int8);
    return val;
  };

  MultiVersionStructV5.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(MultiVersionStructV5.encodedSize);
    encoder.writeUint32(5);
    encoder.encodeStruct(codec.Int32, val.f_int32);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(rect$.Rect, val.f_rect);
    encoder.encodeStruct(codec.NullableString, val.f_string);
    encoder.encodeArrayPointer(codec.Int8, val.f_array);
  };

  function MultiVersionStructV7(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  MultiVersionStructV7.prototype.initDefaults_ = function() {
    this.f_int32 = 0;
    this.f_message_pipe = null;
    this.f_rect = null;
    this.f_string = null;
    this.f_array = null;
    this.f_bool = false;
  };
  MultiVersionStructV7.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  MultiVersionStructV7.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, MultiVersionStructV7.encodedSize, 7);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MultiVersionStructV7.f_message_pipe
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 4, true)
    if (err !== validator.validationError.NONE)
        return err;
    // validate MultiVersionStructV7.f_rect
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, rect$.Rect, true);
    if (err !== validator.validationError.NONE)
        return err;
    // validate MultiVersionStructV7.f_string
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 16, true)
    if (err !== validator.validationError.NONE)
        return err;
    // validate MultiVersionStructV7.f_array
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 1, codec.Int8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  MultiVersionStructV7.encodedSize = codec.kStructHeaderSize + 40;

  MultiVersionStructV7.decode = function(decoder) {
    var packed;
    var val = new MultiVersionStructV7();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.f_int32 = decoder.decodeStruct(codec.Int32);
    val.f_message_pipe = decoder.decodeStruct(codec.NullableHandle);
    val.f_rect = decoder.decodeStructPointer(rect$.Rect);
    val.f_string = decoder.decodeStruct(codec.NullableString);
    val.f_array = decoder.decodeArrayPointer(codec.Int8);
    val.f_bool = decoder.decodeStruct(codec.Uint8);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  MultiVersionStructV7.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(MultiVersionStructV7.encodedSize);
    encoder.writeUint32(7);
    encoder.encodeStruct(codec.Int32, val.f_int32);
    encoder.encodeStruct(codec.NullableHandle, val.f_message_pipe);
    encoder.encodeStructPointer(rect$.Rect, val.f_rect);
    encoder.encodeStruct(codec.NullableString, val.f_string);
    encoder.encodeArrayPointer(codec.Int8, val.f_array);
    encoder.encodeStruct(codec.Uint8, val.f_bool);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };


  var exports = {};
  exports.NamedRegion = NamedRegion;
  exports.RectPair = RectPair;
  exports.EmptyStruct = EmptyStruct;
  exports.NoDefaultFieldValues = NoDefaultFieldValues;
  exports.DefaultFieldValues = DefaultFieldValues;
  exports.ScopedConstants = ScopedConstants;
  exports.MapKeyTypes = MapKeyTypes;
  exports.MapValueTypes = MapValueTypes;
  exports.ArrayValueTypes = ArrayValueTypes;
  exports.FloatNumberValues = FloatNumberValues;
  exports.IntegerNumberValues = IntegerNumberValues;
  exports.UnsignedNumberValues = UnsignedNumberValues;
  exports.BitArrayValues = BitArrayValues;
  exports.MultiVersionStruct = MultiVersionStruct;
  exports.MultiVersionStructV0 = MultiVersionStructV0;
  exports.MultiVersionStructV1 = MultiVersionStructV1;
  exports.MultiVersionStructV3 = MultiVersionStructV3;
  exports.MultiVersionStructV5 = MultiVersionStructV5;
  exports.MultiVersionStructV7 = MultiVersionStructV7;

  module.exports = exports;
</script>
