<!-- Copyright 2014 The Chromium Authors. All rights reserved.
     Use of this source code is governed by a BSD-style license that can be
     found in the LICENSE file. -->

<import src="/gen/mojo/public/sky/bindings.sky" as="bindings" />
<import src="/gen/mojo/public/sky/codec.sky" as="codec" />
<import src="/gen/mojo/public/sky/connection.sky" as="connection" />
<import src="/gen/mojo/public/sky/core.sky" as="core" />
<import src="/gen/mojo/public/sky/validator.sky" as="validator" />
<import src="/gen/mojo/public/interfaces/bindings/tests/regression_tests_import.mojom.sky" as="regression_tests_import$" />
<script>
  var EnumWithReference = {};
  EnumWithReference.k_STEREO_AND_KEYBOARD_MIC = 30;
  EnumWithReference.k_MAX = EnumWithReference.k_STEREO_AND_KEYBOARD_MIC;
  var EnumWithLowercase = {};
  EnumWithLowercase.PlanarF16 = 0;
  EnumWithLowercase.PlanarF32 = EnumWithLowercase.PlanarF16 + 1;
  var EnumWithNumbers = {};
  EnumWithNumbers.k_2_1 = 4;
  var EnumWithK = {};
  EnumWithK.K = 0;

  function Edge(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Edge.prototype.initDefaults_ = function() {
    this.v = null;
  };
  Edge.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Edge.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, Edge.encodedSize, 1);
    if (err !== validator.validationError.NONE)
        return err;
    // validate Edge.v
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, Vertex, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Edge.encodedSize = codec.kStructHeaderSize + 8;

  Edge.decode = function(decoder) {
    var packed;
    var val = new Edge();
    var numberOfBytes = decoder.readUint32();
    var numberOfFields = decoder.readUint32();
    val.v = decoder.decodeStructPointer(Vertex);
    return val;
  };

  Edge.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Edge.encodedSize);
    encoder.writeUint32(1);
    encoder.encodeStructPointer(Vertex, val.v);
  };

  function Vertex(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Vertex.prototype.initDefaults_ = function() {
    this.e = null;
  };
  Vertex.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Vertex.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, Vertex.encodedSize, 1);
    if (err !== validator.validationError.NONE)
        return err;
    // validate Vertex.e
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, EmptyStruct, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Vertex.encodedSize = codec.kStructHeaderSize + 8;

  Vertex.decode = function(decoder) {
    var packed;
    var val = new Vertex();
    var numberOfBytes = decoder.readUint32();
    var numberOfFields = decoder.readUint32();
    val.e = decoder.decodeStructPointer(EmptyStruct);
    return val;
  };

  Vertex.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Vertex.encodedSize);
    encoder.writeUint32(1);
    encoder.encodeStructPointer(EmptyStruct, val.e);
  };

  function EmptyStruct(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  EmptyStruct.prototype.initDefaults_ = function() {
  };
  EmptyStruct.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  EmptyStruct.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, EmptyStruct.encodedSize, 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  EmptyStruct.encodedSize = codec.kStructHeaderSize + 0;

  EmptyStruct.decode = function(decoder) {
    var packed;
    var val = new EmptyStruct();
    var numberOfBytes = decoder.readUint32();
    var numberOfFields = decoder.readUint32();
    return val;
  };

  EmptyStruct.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(EmptyStruct.encodedSize);
    encoder.writeUint32(0);
  };

  function A(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  A.prototype.initDefaults_ = function() {
    this.b = null;
  };
  A.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  A.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, A.encodedSize, 1);
    if (err !== validator.validationError.NONE)
        return err;
    // validate A.b
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, B, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  A.encodedSize = codec.kStructHeaderSize + 8;

  A.decode = function(decoder) {
    var packed;
    var val = new A();
    var numberOfBytes = decoder.readUint32();
    var numberOfFields = decoder.readUint32();
    val.b = decoder.decodeStructPointer(B);
    return val;
  };

  A.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(A.encodedSize);
    encoder.writeUint32(1);
    encoder.encodeStructPointer(B, val.b);
  };

  function B(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  B.prototype.initDefaults_ = function() {
    this.a = null;
  };
  B.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  B.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, B.encodedSize, 1);
    if (err !== validator.validationError.NONE)
        return err;
    // validate B.a
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, A, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  B.encodedSize = codec.kStructHeaderSize + 8;

  B.decode = function(decoder) {
    var packed;
    var val = new B();
    var numberOfBytes = decoder.readUint32();
    var numberOfFields = decoder.readUint32();
    val.a = decoder.decodeStructPointer(A);
    return val;
  };

  B.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(B.encodedSize);
    encoder.writeUint32(1);
    encoder.encodeStructPointer(A, val.a);
  };

  function CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.prototype.initDefaults_ = function() {
  };
  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.encodedSize, 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.encodedSize = codec.kStructHeaderSize + 0;

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.decode = function(decoder) {
    var packed;
    var val = new CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params();
    var numberOfBytes = decoder.readUint32();
    var numberOfFields = decoder.readUint32();
    return val;
  };

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.encodedSize);
    encoder.writeUint32(0);
  };

  function CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.prototype.initDefaults_ = function() {
  };
  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.encodedSize, 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var numberOfFields = decoder.readUint32();
    return val;
  };

  CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };

  function CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.prototype.initDefaults_ = function() {
    this.b = false;
  };
  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.encodedSize, 1);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.encodedSize = codec.kStructHeaderSize + 8;

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.decode = function(decoder) {
    var packed;
    var val = new CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params();
    var numberOfBytes = decoder.readUint32();
    var numberOfFields = decoder.readUint32();
    val.b = decoder.decodeStruct(codec.Uint8);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.encodedSize);
    encoder.writeUint32(1);
    encoder.encodeStruct(codec.Uint8, val.b);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };

  function CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.prototype.initDefaults_ = function() {
  };
  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.encodedSize, 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var numberOfFields = decoder.readUint32();
    return val;
  };

  CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };

  function CheckNameCollision_WithNameCollision_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CheckNameCollision_WithNameCollision_Params.prototype.initDefaults_ = function() {
    this.message = false;
    this.response = false;
  };
  CheckNameCollision_WithNameCollision_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CheckNameCollision_WithNameCollision_Params.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, CheckNameCollision_WithNameCollision_Params.encodedSize, 2);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  CheckNameCollision_WithNameCollision_Params.encodedSize = codec.kStructHeaderSize + 8;

  CheckNameCollision_WithNameCollision_Params.decode = function(decoder) {
    var packed;
    var val = new CheckNameCollision_WithNameCollision_Params();
    var numberOfBytes = decoder.readUint32();
    var numberOfFields = decoder.readUint32();
    packed = decoder.readUint8();
    val.message = (packed >> 0) & 1 ? true : false;
    val.response = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  CheckNameCollision_WithNameCollision_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CheckNameCollision_WithNameCollision_Params.encodedSize);
    encoder.writeUint32(2);
    packed = 0;
    packed |= (val.message & 1) << 0
    packed |= (val.response & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };

  function CheckNameCollision_WithNameCollision_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CheckNameCollision_WithNameCollision_ResponseParams.prototype.initDefaults_ = function() {
    this.message = false;
    this.response = false;
  };
  CheckNameCollision_WithNameCollision_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CheckNameCollision_WithNameCollision_ResponseParams.validate = function(messageValidator, offset) {
    var err;

    err = messageValidator.validateStructHeader(offset, CheckNameCollision_WithNameCollision_ResponseParams.encodedSize, 2);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  CheckNameCollision_WithNameCollision_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  CheckNameCollision_WithNameCollision_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new CheckNameCollision_WithNameCollision_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var numberOfFields = decoder.readUint32();
    packed = decoder.readUint8();
    val.message = (packed >> 0) & 1 ? true : false;
    val.response = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  CheckNameCollision_WithNameCollision_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CheckNameCollision_WithNameCollision_ResponseParams.encodedSize);
    encoder.writeUint32(2);
    packed = 0;
    packed |= (val.message & 1) << 0
    packed |= (val.response & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };

  var kCheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Name = 0;
  var kCheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name = 1;

  function CheckMethodWithEmptyResponseProxy(receiver) {
    bindings.ProxyBase.call(this, receiver);
  }
  CheckMethodWithEmptyResponseProxy.prototype = Object.create(bindings.ProxyBase.prototype);
  CheckMethodWithEmptyResponseProxy.prototype.withouParameterAndEmptyResponse = function() {
    var params = new CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageWithRequestIDBuilder(
          kCheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Name,
          codec.align(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params, params);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  CheckMethodWithEmptyResponseProxy.prototype.withParameterAndEmptyResponse = function(b) {
    var params = new CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params();
    params.b = b;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageWithRequestIDBuilder(
          kCheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name,
          codec.align(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params, params);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function CheckMethodWithEmptyResponseStub(delegate) {
    bindings.StubBase.call(this, delegate);
  }
  CheckMethodWithEmptyResponseStub.prototype = Object.create(bindings.StubBase.prototype);
  CheckMethodWithEmptyResponseStub.prototype.withouParameterAndEmptyResponse = function() {
    return bindings.StubBindings(this).delegate && bindings.StubBindings(this).delegate.withouParameterAndEmptyResponse && bindings.StubBindings(this).delegate.withouParameterAndEmptyResponse();
  }
  CheckMethodWithEmptyResponseStub.prototype.withParameterAndEmptyResponse = function(b) {
    return bindings.StubBindings(this).delegate && bindings.StubBindings(this).delegate.withParameterAndEmptyResponse && bindings.StubBindings(this).delegate.withParameterAndEmptyResponse(b);
  }

  CheckMethodWithEmptyResponseStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  CheckMethodWithEmptyResponseStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kCheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Name:
      var params = reader.decodeStruct(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params);
      return this.withouParameterAndEmptyResponse().then(function(response) {
        var responseParams =
            new CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams();
        var builder = new codec.MessageWithRequestIDBuilder(
            kCheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Name,
            codec.align(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
    case kCheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name:
      var params = reader.decodeStruct(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params);
      return this.withParameterAndEmptyResponse(params.b).then(function(response) {
        var responseParams =
            new CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams();
        var builder = new codec.MessageWithRequestIDBuilder(
            kCheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name,
            codec.align(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
    default:
      return Promise.reject(Error("Unhandled message: " + reader.messageName));
    }
  };

  function validateCheckMethodWithEmptyResponseRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kCheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Name:
        if (message.expectsResponse())
          paramsClass = CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Params;
      break;
      case kCheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name:
        if (message.expectsResponse())
          paramsClass = CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateCheckMethodWithEmptyResponseResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kCheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_Name:
        if (message.isResponse())
          paramsClass = CheckMethodWithEmptyResponse_WithouParameterAndEmptyResponse_ResponseParams;
        break;
      case kCheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_Name:
        if (message.isResponse())
          paramsClass = CheckMethodWithEmptyResponse_WithParameterAndEmptyResponse_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var CheckMethodWithEmptyResponse = {
    name: 'regression_tests::CheckMethodWithEmptyResponse',
    proxyClass: CheckMethodWithEmptyResponseProxy,
    stubClass: CheckMethodWithEmptyResponseStub,
    validateRequest: validateCheckMethodWithEmptyResponseRequest,
    validateResponse: validateCheckMethodWithEmptyResponseResponse,
  };
  CheckMethodWithEmptyResponseStub.prototype.validator = validateCheckMethodWithEmptyResponseRequest;
  CheckMethodWithEmptyResponseProxy.prototype.validator = validateCheckMethodWithEmptyResponseResponse;

  var kCheckNameCollision_WithNameCollision_Name = 0;

  function CheckNameCollisionProxy(receiver) {
    bindings.ProxyBase.call(this, receiver);
  }
  CheckNameCollisionProxy.prototype = Object.create(bindings.ProxyBase.prototype);
  CheckNameCollisionProxy.prototype.withNameCollision = function(message, response) {
    var params = new CheckNameCollision_WithNameCollision_Params();
    params.message = message;
    params.response = response;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageWithRequestIDBuilder(
          kCheckNameCollision_WithNameCollision_Name,
          codec.align(CheckNameCollision_WithNameCollision_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(CheckNameCollision_WithNameCollision_Params, params);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(CheckNameCollision_WithNameCollision_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function CheckNameCollisionStub(delegate) {
    bindings.StubBase.call(this, delegate);
  }
  CheckNameCollisionStub.prototype = Object.create(bindings.StubBase.prototype);
  CheckNameCollisionStub.prototype.withNameCollision = function(message, response) {
    return bindings.StubBindings(this).delegate && bindings.StubBindings(this).delegate.withNameCollision && bindings.StubBindings(this).delegate.withNameCollision(message, response);
  }

  CheckNameCollisionStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  CheckNameCollisionStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kCheckNameCollision_WithNameCollision_Name:
      var params = reader.decodeStruct(CheckNameCollision_WithNameCollision_Params);
      return this.withNameCollision(params.message, params.response).then(function(response) {
        var responseParams =
            new CheckNameCollision_WithNameCollision_ResponseParams();
        responseParams.message = response.message;
        responseParams.response = response.response;
        var builder = new codec.MessageWithRequestIDBuilder(
            kCheckNameCollision_WithNameCollision_Name,
            codec.align(CheckNameCollision_WithNameCollision_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(CheckNameCollision_WithNameCollision_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
    default:
      return Promise.reject(Error("Unhandled message: " + reader.messageName));
    }
  };

  function validateCheckNameCollisionRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kCheckNameCollision_WithNameCollision_Name:
        if (message.expectsResponse())
          paramsClass = CheckNameCollision_WithNameCollision_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateCheckNameCollisionResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kCheckNameCollision_WithNameCollision_Name:
        if (message.isResponse())
          paramsClass = CheckNameCollision_WithNameCollision_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var CheckNameCollision = {
    name: 'regression_tests::CheckNameCollision',
    proxyClass: CheckNameCollisionProxy,
    stubClass: CheckNameCollisionStub,
    validateRequest: validateCheckNameCollisionRequest,
    validateResponse: validateCheckNameCollisionResponse,
  };
  CheckNameCollisionStub.prototype.validator = validateCheckNameCollisionRequest;
  CheckNameCollisionProxy.prototype.validator = validateCheckNameCollisionResponse;


  function InterfaceWithClientImportedProxy(receiver) {
    bindings.ProxyBase.call(this, receiver);
  }
  InterfaceWithClientImportedProxy.prototype = Object.create(bindings.ProxyBase.prototype);

  function InterfaceWithClientImportedStub(delegate) {
    bindings.StubBase.call(this, delegate);
  }
  InterfaceWithClientImportedStub.prototype = Object.create(bindings.StubBase.prototype);

  InterfaceWithClientImportedStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  InterfaceWithClientImportedStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return Promise.reject(Error("Unhandled message: " + reader.messageName));
    }
  };

  function validateInterfaceWithClientImportedRequest(messageValidator) {
    return validator.validationError.NONE;
  }

  function validateInterfaceWithClientImportedResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var InterfaceWithClientImported = {
    name: 'regression_tests::InterfaceWithClientImported',
    proxyClass: InterfaceWithClientImportedProxy,
    stubClass: InterfaceWithClientImportedStub,
    validateRequest: validateInterfaceWithClientImportedRequest,
    validateResponse: null,
  };
  InterfaceWithClientImportedStub.prototype.validator = validateInterfaceWithClientImportedRequest;
  InterfaceWithClientImportedProxy.prototype.validator = null;


  var exports = {};
  exports.EnumWithReference = EnumWithReference;
  exports.EnumWithLowercase = EnumWithLowercase;
  exports.EnumWithNumbers = EnumWithNumbers;
  exports.EnumWithK = EnumWithK;
  exports.Edge = Edge;
  exports.Vertex = Vertex;
  exports.EmptyStruct = EmptyStruct;
  exports.A = A;
  exports.B = B;
  exports.CheckMethodWithEmptyResponse = CheckMethodWithEmptyResponse;
  exports.CheckNameCollision = CheckNameCollision;
  exports.InterfaceWithClientImported = InterfaceWithClientImported;
  exports.InterfaceWithClientImported.client = regression_tests_import$.InterfaceWithClientImportedClient;

  module.exports = exports;
</script>
